{
  "benchmark": [
    {
      "id": "002",
      "requirement": "If VehicleTempo, SteeringDynamic, and LightSensorState are valid, the HeadlampPatternCommand shall be computed as follows: if VehicleTempo > SpeedHighThreshold and SteeringDynamic magnitude > SteeringDynamicThreshold, HeadlampPatternCommand shall be set to 'AdaptiveCorner'. If VehicleTempo <= SpeedHighThreshold or SteeringDynamic magnitude <= SteeringDynamicThreshold, HeadlampPatternCommand shall be set to 'ForwardWide'. If any of the inputs are 'Fault' or 'Unavailable', HeadlampPatternCommand shall be set to 'SafeLow'. When TurnIndicatorActive transitions to 'True', HeadlampPatternCommand shall be set to 'TurnAssist' for 5 s, then revert to the previously determined pattern.",
      "response": "def compute_headlamp_pattern(state, vehicle_tempo, steering_dynamic, light_sensor_state, \n                            turn_indicator_active, speed_high_threshold, steering_dynamic_threshold, dt):\n    import math\n    \n    # Simple state management\n    turn_timer = state.get('turn_timer', 0)\n    prev_turn_active = state.get('prev_turn_active', False)\n    base_pattern = state.get('base_pattern', 'SafeLow')\n    \n    # Check for turn indicator edge\n    turn_edge = turn_indicator_active and not prev_turn_active\n    \n    # Update turn timer\n    if turn_indicator_active:\n        if turn_edge:\n            turn_timer = 5.0\n        else:\n            turn_timer = max(0, turn_timer - dt)\n    else:\n        turn_timer = 0\n    \n    # Determine base pattern when not in turn assist\n    if turn_timer == 0 or turn_edge:\n        fault_values = ['Fault', 'Unavailable']\n        if (vehicle_tempo in fault_values or steering_dynamic in fault_values or light_sensor_state in fault_values):\n            base_pattern = 'SafeLow'\n        else:\n            steering_magnitude = abs(steering_dynamic) if isinstance(steering_dynamic, (int, float)) else 0\n            if vehicle_tempo > speed_high_threshold and steering_magnitude > steering_dynamic_threshold:\n                base_pattern = 'AdaptiveCorner'\n            else:\n                base_pattern = 'ForwardWide'\n    \n    # Apply turn assist override\n    final_pattern = 'TurnAssist' if turn_timer > 0 else base_pattern\n    \n    # Update state\n    state['turn_timer'] = turn_timer\n    state['prev_turn_active'] = turn_indicator_active\n    state['base_pattern'] = base_pattern\n    \n    return final_pattern"
    },
    {
      "id": "010",
      "requirement": "If KeyProximityDistance is valid and less than ProximityThreshold and ExteriorHandleTouch transitions from 'No' to 'Yes', HandlePresentationCommand shall be set to 'Present' for 5 s. If DoorOpenDetected is 'False' at the end of 5 s, HandlePresentationCommand shall be set to 'Retract'. If KeyProximityDistance becomes 'Unavailable' during presentation, HandlePresentationCommand shall be set to 'Retract' within 1 s.",
      "response": "def handle_presentation_logic(state, key_proximity_distance, proximity_threshold, \n                             exterior_handle_touch, door_open_detected, dt):\n    # Quick and dirty implementation with basic state tracking\n    t = state.setdefault('presentation_timer', 0)\n    fault_t = state.setdefault('fault_timer', 0)\n    prev_touch = state.setdefault('prev_touch', 'No')\n    cmd = state.setdefault('command', 'Retract')\n    presenting = state.setdefault('presenting', False)\n    \n    # Touch edge detection\n    touch_edge = prev_touch == 'No' and exterior_handle_touch == 'Yes'\n    \n    # Start presentation on valid conditions\n    if (touch_edge and \n        key_proximity_distance != 'Unavailable' and \n        isinstance(key_proximity_distance, (int, float)) and \n        key_proximity_distance < proximity_threshold):\n        cmd = 'Present'\n        t = 5.0\n        presenting = True\n        fault_t = 0\n    \n    # Handle presentation timing\n    if presenting and t > 0:\n        t -= dt\n        if t <= 0:\n            if not door_open_detected:\n                cmd = 'Retract'\n            presenting = False\n    \n    # Handle proximity fault during presentation\n    if presenting and key_proximity_distance == 'Unavailable':\n        fault_t += dt\n        if fault_t >= 1.0:\n            cmd = 'Retract'\n            presenting = False\n            fault_t = 0\n    elif presenting:\n        fault_t = 0\n    \n    # Update state\n    state.update({\n        'presentation_timer': t,\n        'fault_timer': fault_t,\n        'prev_touch': exterior_handle_touch,\n        'command': cmd,\n        'presenting': presenting\n    })\n    \n    return cmd"
    },
    {
      "id": "012",
      "requirement": "If LaneAssistEnable is 'On', LaneMarkingsQuality is 'Good', and SteeringWheelContact is 'HandsOn', then LaneAssistState shall be set to 'Active'. If SteeringWheelContact transitions to 'HandsOff', WarningHandsOff shall be set to 'On' after 15 s; if hands remain off for 30 s, LaneAssistState shall be set to 'Suspended' and a disengagement chime shall be requested. LaneAssistState shall return to 'Active' when SteeringWheelContact returns to 'HandsOn' and LaneMarkingsQuality is 'Good'.",
      "response": "def lane_assist_controller(inputs, state, dt):\n    \"\"\"Lane assist with hands-off detection - function signature variation\"\"\"\n    \n    # Unpack inputs for readability\n    enable = inputs.get('lane_assist_enable')\n    markings = inputs.get('lane_markings_quality')\n    contact = inputs.get('steering_wheel_contact')\n    \n    # State management\n    assist_state = state.get('assist_state', 'Inactive')\n    hands_off_timer = state.get('hands_off_timer', 0.0)\n    warning_hands_off = state.get('warning_hands_off', 'Off')\n    chime_requested = state.get('chime_requested', False)\n    prev_contact = state.get('prev_contact', 'HandsOn')\n    \n    # Detect hands-off transition\n    hands_off_transition = (prev_contact == 'HandsOn' and contact == 'HandsOff')\n    hands_on_transition = (prev_contact == 'HandsOff' and contact == 'HandsOn')\n    \n    # Reset timer on hands-on transition\n    if hands_on_transition:\n        hands_off_timer = 0.0\n        warning_hands_off = 'Off'\n        chime_requested = False\n    \n    # Handle hands-off timing\n    if contact == 'HandsOff':\n        if hands_off_transition:\n            hands_off_timer = 0.0  # Start fresh timing\n        hands_off_timer += dt\n        \n        # Warning after 15 seconds\n        if hands_off_timer >= 15.0:\n            warning_hands_off = 'On'\n        \n        # Suspension after 30 seconds\n        if hands_off_timer >= 30.0 and assist_state == 'Active':\n            assist_state = 'Suspended'\n            chime_requested = True\n    \n    # Determine main assist state\n    conditions_met = (enable == 'On' and \n                     markings == 'Good' and \n                     contact == 'HandsOn')\n    \n    if conditions_met:\n        if assist_state in ['Inactive', 'Suspended']:\n            assist_state = 'Active'\n    elif enable != 'On' or markings != 'Good':\n        assist_state = 'Inactive'\n        hands_off_timer = 0.0\n        warning_hands_off = 'Off'\n        chime_requested = False\n    \n    # Store updated state\n    state.update({\n        'assist_state': assist_state,\n        'hands_off_timer': hands_off_timer,\n        'warning_hands_off': warning_hands_off,\n        'chime_requested': chime_requested,\n        'prev_contact': contact\n    })\n    \n    outputs = {\n        'lane_assist_state': assist_state,\n        'warning_hands_off': warning_hands_off,\n        'disengagement_chime': chime_requested\n    }\n    \n    return outputs"
    },
    {
      "id": "015",
      "requirement": "When TransGear transitions to 'Reverse' or CameraRequestButtonState transitions to 'Pressed', RearCameraDisplayState shall be set to 'On'. If VehicleTempo exceeds 15 km/h continuously for 3 s while TransGear is not 'Reverse', RearCameraDisplayState shall be set to 'Off' unless TrailerAssistMode is 'Enabled'. If RearCameraVideoSignal is 'Unavailable' or 'Fault', RearCameraDisplayState shall be set to 'Off' and CameraFaultIndicator shall be set to 'On'.",
      "response": "def rear_camera_display_manager(state, trans_gear, camera_request_button_state, vehicle_tempo,\n                               trailer_assist_mode, rear_camera_video_signal, dt):\n    # Ultra-compact style with minimal state\n    d = state  # Even shorter alias\n    display = d.get('display_state', 'Off')\n    fault = d.get('fault_indicator', 'Off')\n    speed_t = d.get('speed_timer', 0)\n    prev_gear = d.get('prev_gear', 'Park')\n    prev_btn = d.get('prev_button', 'Released')\n    \n    # Edge detection\n    gear_to_reverse = trans_gear == 'Reverse' and prev_gear != 'Reverse'\n    btn_pressed = camera_request_button_state == 'Pressed' and prev_btn != 'Pressed'\n    \n    # Video signal fault check\n    video_fault = rear_camera_video_signal in ['Unavailable', 'Fault']\n    if video_fault:\n        display, fault = 'Off', 'On'\n    else:\n        fault = 'Off'\n        \n        # Activation triggers\n        if gear_to_reverse or btn_pressed:\n            display = 'On'\n            speed_t = 0\n        \n        # Speed-based deactivation\n        if (trans_gear != 'Reverse' and \n            isinstance(vehicle_tempo, (int, float)) and \n            vehicle_tempo > 15):\n            speed_t += dt\n            if speed_t >= 3.0 and trailer_assist_mode != 'Enabled':\n                display = 'Off'\n        else:\n            speed_t = 0\n    \n    # State update\n    d.update({\n        'display_state': display,\n        'fault_indicator': fault,\n        'speed_timer': speed_t,\n        'prev_gear': trans_gear,\n        'prev_button': camera_request_button_state\n    })\n    \n    return display, fault"
    },
    {
      "id": "018",
      "requirement": "If any TirePressure value is valid and below LowPressureThreshold for more than 60 s while VehicleTempo exceeds 25 km/h, LowPressureWarning shall be set to 'On' for the affected wheel position. If the corresponding TirePressure sensor is 'Unavailable' or 'Fault', SystemStatusTPMS shall be set to 'Fault' and LowPressureWarning shall be set to 'Off'. LowPressureWarning shall be cleared when TirePressure rises above ClearPressureThreshold for 120 s.",
      "response": "def tire_pressure_monitoring(state, tire_pressures, vehicle_tempo, low_pressure_threshold, \n                           clear_pressure_threshold, dt):\n    \"\"\"\n    TPMS with per-wheel state tracking - dictionary-heavy approach\n    tire_pressures: dict with keys like 'FL', 'FR', 'RL', 'RR'\n    \"\"\"\n    \n    # Initialize state for each wheel position\n    if 'wheel_states' not in state:\n        state['wheel_states'] = {}\n    \n    if 'system_status' not in state:\n        state['system_status'] = 'Normal'\n    \n    wheel_states = state['wheel_states']\n    warnings = {}\n    system_fault = False\n    \n    # Process each wheel\n    for position, pressure in tire_pressures.items():\n        # Initialize wheel state if needed\n        if position not in wheel_states:\n            wheel_states[position] = {\n                'low_timer': 0.0,\n                'clear_timer': 0.0,\n                'warning_active': False\n            }\n        \n        wheel_state = wheel_states[position]\n        \n        # Check for sensor faults\n        if pressure in ['Unavailable', 'Fault']:\n            system_fault = True\n            wheel_state['warning_active'] = False\n            wheel_state['low_timer'] = 0.0\n            wheel_state['clear_timer'] = 0.0\n            warnings[position] = 'Off'\n            continue\n        \n        # Validate pressure is numeric\n        if not isinstance(pressure, (int, float)):\n            continue\n        \n        # Low pressure detection\n        if pressure < low_pressure_threshold and vehicle_tempo > 25:\n            wheel_state['low_timer'] += dt\n            wheel_state['clear_timer'] = 0.0\n            \n            if wheel_state['low_timer'] >= 60.0 and not wheel_state['warning_active']:\n                wheel_state['warning_active'] = True\n        \n        # Pressure recovery detection\n        elif pressure > clear_pressure_threshold and wheel_state['warning_active']:\n            wheel_state['clear_timer'] += dt\n            wheel_state['low_timer'] = 0.0\n            \n            if wheel_state['clear_timer'] >= 120.0:\n                wheel_state['warning_active'] = False\n                wheel_state['clear_timer'] = 0.0\n        \n        # Reset timers if conditions change\n        else:\n            if pressure >= low_pressure_threshold or vehicle_tempo <= 25:\n                wheel_state['low_timer'] = 0.0\n            if pressure <= clear_pressure_threshold:\n                wheel_state['clear_timer'] = 0.0\n        \n        # Set warning output\n        warnings[position] = 'On' if wheel_state['warning_active'] else 'Off'\n    \n    # Update system status\n    state['system_status'] = 'Fault' if system_fault else 'Normal'\n    \n    return warnings, state['system_status']"
    }
  ]
}