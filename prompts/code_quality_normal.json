{
  "evaluate": {
    "traces": [],
    "train": [],
    "demos": [
      {
        "augmented": true,
        "function": "def update_wheel_heater(state, wheel_heater_button_state, ambient_temp, wheel_heater_temp_feedback, cold_threshold, dt):\n    # Initialize state variables\n    if 'prev_button_state' not in state:\n        state['prev_button_state'] = 'Released'\n    if 'heater_mode' not in state:\n        state['heater_mode'] = 'Off'\n    if 'heater_level' not in state:\n        state['heater_level'] = 'Off'\n    if 'boost_timer' not in state:\n        state['boost_timer'] = 0.0\n    \n    # Detect button press edge\n    button_pressed_edge = (state['prev_button_state'] == 'Released' and \n                          wheel_heater_button_state == 'Pressed')\n    button_released_edge = (state['prev_button_state'] == 'Pressed' and \n                           wheel_heater_button_state == 'Released')\n    \n    # Handle button press\n    if button_pressed_edge:\n        if ambient_temp not in ['Fault', 'Unavailable']:\n            if ambient_temp <= cold_threshold:\n                state['heater_mode'] = 'Boost'\n                state['heater_level'] = 'High'\n                state['boost_timer'] = 180.0\n            else:\n                state['heater_mode'] = 'Normal'\n                state['heater_level'] = 'Medium'\n    \n    # Handle button release\n    if button_released_edge:\n        state['heater_mode'] = 'Standby'\n    \n    # Handle boost timer\n    if state['heater_mode'] == 'Boost':\n        state['boost_timer'] -= dt\n        if state['boost_timer'] <= 0:\n            state['heater_mode'] = 'Normal'\n            state['heater_level'] = 'Medium'\n        \n        # Check for faults during boost\n        if (ambient_temp in ['Fault', 'Unavailable'] or \n            wheel_heater_temp_feedback in ['Fault', 'Unavailable']):\n            state['heater_mode'] = 'Off'\n            state['heater_level'] = 'Off'\n    \n    state['prev_button_state'] = wheel_heater_button_state\n    return state['heater_mode'], state['heater_level']",
        "score": 3.142857142857143
      },
      {
        "augmented": true,
        "function": "def wiper_control_logic(state, swipe_mode, rain_strength, vehicle_tempo, driver_wiper_override, \n                       driver_wiper_position, ignition_state, rain_low_threshold, rain_high_threshold, dt):\n    # State initialization - using dict.get() for cleaner code\n    low_rain_timer = state.get('low_rain_timer', 0.0)\n    auto_suspended = state.get('auto_suspended', False)\n    suspend_timer = state.get('suspend_timer', 0.0)\n    prev_override = state.get('prev_override', 'Inactive')\n    \n    # Check for driver override transition\n    override_activated = (prev_override != 'Active' and driver_wiper_override == 'Active')\n    \n    if override_activated:\n        auto_suspended = True\n        suspend_timer = 600.0  # 10 minutes\n    \n    # Handle suspension timer and ignition off\n    if auto_suspended:\n        if ignition_state == 'Off':\n            auto_suspended = False\n            suspend_timer = 0.0\n        elif suspend_timer > 0:\n            suspend_timer -= dt\n            if suspend_timer <= 0:\n                auto_suspended = False\n    \n    # Determine wiper command\n    if auto_suspended:\n        wiper_command = driver_wiper_position\n    elif swipe_mode == 'Auto' and rain_strength not in ['Fault', 'Unavailable']:\n        if rain_strength >= rain_high_threshold and vehicle_tempo >= 5:\n            wiper_command = 'Fast'\n            low_rain_timer = 0.0\n        elif rain_low_threshold <= rain_strength < rain_high_threshold:\n            wiper_command = 'Normal'\n            low_rain_timer = 0.0\n        elif rain_strength < rain_low_threshold:\n            low_rain_timer += dt\n            wiper_command = 'Intermittent' if low_rain_timer >= 15.0 else state.get('wiper_command', 'Normal')\n        else:\n            wiper_command = 'Normal'\n    else:\n        wiper_command = 'Off'\n    \n    # Update state\n    state.update({\n        'low_rain_timer': low_rain_timer,\n        'auto_suspended': auto_suspended,\n        'suspend_timer': suspend_timer,\n        'prev_override': driver_wiper_override,\n        'wiper_command': wiper_command\n    })\n    \n    return wiper_command, auto_suspended",
        "score": 3.7142857142857135
      },
      {
        "augmented": true,
        "function": "def door_lock_controller(state, door_ajar_signals, gear_selector, vehicle_tempo, \n                        crash_event_detected, ignition_state, dt):\n    \"\"\"\n    Basic door lock control - straightforward implementation\n    \"\"\"\n    speed_timer = state.get('speed_timer', 0)\n    crash_unlock_active = state.get('crash_unlock_active', False)\n    prev_crash = state.get('prev_crash', False)\n    current_command = state.get('door_lock_command', 'NoChange')\n    \n    # Crash detection edge\n    crash_edge = crash_event_detected and not prev_crash\n    \n    # Handle crash unlock\n    if crash_edge:\n        crash_unlock_active = True\n        current_command = 'UnlockAll'\n    \n    if crash_unlock_active and ignition_state == 'Off':\n        crash_unlock_active = False\n    \n    # If crash unlock is active, maintain unlock command\n    if crash_unlock_active:\n        current_command = 'UnlockAll'\n    else:\n        # Check normal locking conditions\n        all_doors_closed = all(signal == 'Closed' for signal in door_ajar_signals)\n        \n        if (all_doors_closed and gear_selector != 'Park' and vehicle_tempo > 15):\n            speed_timer += dt\n            if speed_timer >= 5.0:\n                current_command = 'LockAll'\n        else:\n            speed_timer = 0\n        \n        # Door ajar while moving check - command remains unchanged as per requirement\n        # This is implicitly handled by not changing current_command\n    \n    # Save state\n    state['speed_timer'] = speed_timer\n    state['crash_unlock_active'] = crash_unlock_active\n    state['prev_crash'] = crash_event_detected\n    state['door_lock_command'] = current_command\n    \n    return current_command",
        "score": 3.4285714285714284
      },
      {
        "augmented": true,
        "function": "def preconditioning_manager(departure_timer_active, connector_state, energy_reserve_percent, \n                           preconditioning_min_reserve, departure_time, current_time, hvac_sensors):\n    \"\"\"\n    Cabin preconditioning with time-based logic - more verbose style\n    \"\"\"\n    \n    def check_hvac_sensors_valid(sensors):\n        \"\"\"Helper function to validate HVAC sensors\"\"\"\n        for sensor_name, sensor_value in sensors.items():\n            if sensor_value in ['Fault', 'Unavailable']:\n                return False\n        return True\n    \n    # Calculate time differences\n    time_to_departure = departure_time - current_time\n    twenty_min_mark = 20 * 60  # 20 minutes in seconds\n    five_min_mark = 5 * 60     # 5 minutes in seconds\n    two_min_interval = 2 * 60  # 2 minutes in seconds\n    \n    # Check HVAC sensors first - immediate abort if faulty\n    if not check_hvac_sensors_valid(hvac_sensors):\n        return 'Abort'\n    \n    # Main preconditioning logic\n    if not departure_timer_active:\n        return 'Off'\n    \n    if energy_reserve_percent < preconditioning_min_reserve:\n        return 'InsufficientEnergy'\n    \n    # Time-based decision making\n    if time_to_departure <= five_min_mark:\n        # Too late to start if still unplugged\n        if connector_state == 'Unplugged':\n            return 'Skip'\n        elif connector_state == 'Plugged':\n            return 'Start'\n    elif time_to_departure <= twenty_min_mark:\n        # In the defer/retry window\n        if connector_state == 'Unplugged':\n            # Check if we're at a 2-minute evaluation point\n            remaining_defer_time = time_to_departure - five_min_mark\n            if remaining_defer_time % two_min_interval < 1:  # Close to eval point\n                return 'Defer'\n            else:\n                return 'Defer'  # Keep deferring\n        else:\n            return 'Start'\n    elif time_to_departure == twenty_min_mark:\n        # Exactly at the 20-minute mark\n        if connector_state == 'Plugged':\n            return 'Start'\n        else:\n            return 'Defer'\n    else:\n        # Too early\n        return 'Standby'\n    \n    return 'Standby'",
        "score": 4.0
      },
      {
        "function": "def trailer_stability_system(state, status_of_connection, vehicle_tempo, yaw_rate_oscillation_amplitude,\n                            yaw_amplitude_threshold, hysteresis_yaw_threshold, dt):\n    \"\"\"\n    Trailer stability control with pulse management - professional style with logging\n    \"\"\"\n    import time\n    \n    # Comprehensive state management\n    intervention_active = state.get('intervention_active', False)\n    activation_timer = state.get('activation_timer', 0.0)\n    deactivation_timer = state.get('deactivation_timer', 0.0)\n    pulse_timer = state.get('pulse_timer', 0.0)\n    pulse_count_1min = state.get('pulse_count_1min', 0)\n    pulse_timestamps = state.get('pulse_timestamps', [])\n    last_pulse_time = state.get('last_pulse_time', 0.0)\n    brake_pulse_active = state.get('brake_pulse_active', False)\n    \n    # Input validation with logging capability\n    def log_debug(message):\n        # In real system, this would log to vehicle diagnostics\n        pass\n    \n    current_time = time.time()  # In real system, use vehicle time\n    \n    # Validate inputs\n    if not isinstance(vehicle_tempo, (int, float)):\n        log_debug(f\"Invalid vehicle tempo: {vehicle_tempo}\")\n        return 'Inactive', False\n    \n    if not isinstance(yaw_rate_oscillation_amplitude, (int, float)):\n        log_debug(f\"Invalid yaw amplitude: {yaw_rate_oscillation_amplitude}\")\n        return 'Inactive', False\n    \n    # Clean up old pulse timestamps (remove entries older than 1 minute)\n    current_pulse_timestamps = [ts for ts in pulse_timestamps if current_time - ts < 60.0]\n    pulse_count_1min = len(current_pulse_timestamps)\n    \n    # Activation logic\n    activation_conditions = (\n        status_of_connection == 'Connected' and\n        vehicle_tempo > 60 and\n        yaw_rate_oscillation_amplitude > yaw_amplitude_threshold\n    )\n    \n    if activation_conditions and not intervention_active:\n        activation_timer += dt\n        if activation_timer > 0.2:  # 200ms threshold\n            intervention_active = True\n            deactivation_timer = 0.0\n            log_debug(\"Trailer stability intervention activated\")\n    elif not activation_conditions:\n        activation_timer = 0.0\n    \n    # Deactivation logic\n    deactivation_conditions = (\n        yaw_rate_oscillation_amplitude < hysteresis_yaw_threshold\n    )\n    \n    if intervention_active and deactivation_conditions:\n        deactivation_timer += dt\n        if deactivation_timer >= 2.0:  # 2 second threshold\n            intervention_active = False\n            activation_timer = 0.0\n            log_debug(\"Trailer stability intervention deactivated\")\n    elif intervention_active and not deactivation_conditions:\n        deactivation_timer = 0.0\n    \n    # Brake pulse management\n    if intervention_active:\n        pulse_timer += dt\n        \n        # Check if we can apply a pulse (respect timing and count limits)\n        can_pulse = (\n            pulse_timer >= 0.3 and  # 300ms minimum interval\n            pulse_count_1min < 10 and  # Max 10 per minute\n            not brake_pulse_active\n        )\n        \n        if can_pulse:\n            brake_pulse_active = True\n            current_pulse_timestamps.append(current_time)\n            pulse_count_1min += 1\n            pulse_timer = 0.0\n            log_debug(f\"Brake pulse applied. Count this minute: {pulse_count_1min}\")\n    else:\n        brake_pulse_active = False\n        pulse_timer = 0.0\n    \n    # Update state\n    state.update({\n        'intervention_active': intervention_active,\n        'activation_timer': activation_timer,\n        'deactivation_timer': deactivation_timer,\n        'pulse_timer': pulse_timer,\n        'pulse_count_1min': pulse_count_1min,\n        'pulse_timestamps': current_pulse_timestamps,\n        'last_pulse_time': current_time if brake_pulse_active else last_pulse_time,\n        'brake_pulse_active': brake_pulse_active\n    })\n    \n    return 'Active' if intervention_active else 'Inactive', brake_pulse_active",
        "score": 3.571428571428572
      },
      {
        "function": "def regenerative_braking_control(state, regen_enable, brake_pedal_pressure, driver_regen_request,\n                                regen_max_torque, wheel_slip_control_active, brake_system_active,\n                                ramp_rate_regen, dt):\n    \"\"\"\n    Regen braking with blend control - intermediate complexity with error handling\n    \"\"\"\n    \n    # State initialization with type hints in comments\n    current_torque = state.get('regen_torque', 0.0)  # float\n    reduction_timer = state.get('reduction_timer', 0.0)  # float\n    recovery_timer = state.get('recovery_timer', 0.0)  # float\n    prev_wheel_slip = state.get('prev_wheel_slip', False)  # bool\n    blend_request = state.get('blend_request', 'None')  # str\n    is_reducing = state.get('is_reducing', False)  # bool\n    \n    # Input validation and error handling\n    try:\n        driver_request = float(driver_regen_request) if driver_regen_request != 'Unavailable' else 0.0\n        max_torque = float(regen_max_torque) if regen_max_torque != 'Unavailable' else 0.0\n        ramp_rate = float(ramp_rate_regen) if ramp_rate_regen != 'Unavailable' else 100.0\n    except (ValueError, TypeError):\n        driver_request = max_torque = ramp_rate = 0.0\n    \n    # Detect slip control activation\n    slip_activated = wheel_slip_control_active and not prev_wheel_slip\n    \n    # Determine if immediate reduction is needed\n    need_immediate_reduction = (slip_activated or brake_system_active)\n    \n    if need_immediate_reduction and not is_reducing:\n        is_reducing = True\n        reduction_timer = 0.1  # 100ms to reduce to zero\n        blend_request = 'Increase'\n        recovery_timer = 0.0\n    \n    # Handle torque reduction phase\n    if is_reducing and reduction_timer > 0:\n        reduction_timer -= dt\n        # Linear reduction to zero over 100ms\n        reduction_factor = max(0.0, reduction_timer / 0.1)\n        current_torque *= reduction_factor\n        \n        if reduction_timer <= 0:\n            current_torque = 0.0\n            is_reducing = False\n    \n    # Handle recovery conditions\n    conditions_clear = (not brake_system_active and not wheel_slip_control_active)\n    \n    if conditions_clear:\n        recovery_timer += dt\n        if recovery_timer >= 0.5:  # 500ms\n            blend_request = 'None'\n    else:\n        recovery_timer = 0.0\n    \n    # Normal operation or recovery ramping\n    if not is_reducing and conditions_clear and recovery_timer >= 0.5:\n        if regen_enable and not brake_pedal_pressure:\n            target_torque = min(driver_request, max_torque)\n            \n            # Ramp towards target\n            if current_torque < target_torque:\n                current_torque = min(current_torque + ramp_rate * dt, target_torque)\n            elif current_torque > target_torque:\n                current_torque = max(current_torque - ramp_rate * dt, target_torque)\n        else:\n            current_torque = 0.0\n    \n    # Update state\n    state.update({\n        'regen_torque': current_torque,\n        'reduction_timer': reduction_timer,\n        'recovery_timer': recovery_timer,\n        'prev_wheel_slip': wheel_slip_control_active,\n        'blend_request': blend_request,\n        'is_reducing': is_reducing\n    })\n    \n    return current_torque, blend_request",
        "score": 3.4285714285714284
      },
      {
        "function": "def ota_update_state_machine(state, update_package_available, gear_selector, energy_reserve_percent,\n                            vehicle_use_state, verification_status, user_consent, update_apply_status,\n                            apply_timeout, dt):\n    # State machine approach with explicit states\n    UPDATE_STATES = {\n        'IDLE': 0,\n        'DOWNLOAD_READY': 1,\n        'DOWNLOADING': 2,\n        'DOWNLOAD_COMPLETE': 3,\n        'APPLYING': 4,\n        'SUCCESS': 5,\n        'FAILED': 6\n    }\n    \n    current_state = state.get('update_state', UPDATE_STATES['IDLE'])\n    download_cmd = state.get('download_command', 'Stop')\n    apply_cmd = state.get('apply_command', 'Stop')\n    rollback_cmd = state.get('rollback_command', 'Stop')\n    update_status = state.get('update_status', 'None')\n    apply_timer = state.get('apply_timer', 0.0)\n    \n    # State transitions\n    if current_state == UPDATE_STATES['IDLE']:\n        download_conditions = (\n            update_package_available == 'True' and\n            gear_selector == 'Park' and\n            energy_reserve_percent >= 40 and\n            vehicle_use_state == 'Idle'\n        )\n        \n        if download_conditions:\n            current_state = UPDATE_STATES['DOWNLOAD_READY']\n            download_cmd = 'Start'\n    \n    elif current_state == UPDATE_STATES['DOWNLOAD_READY']:\n        if download_cmd == 'Start':\n            current_state = UPDATE_STATES['DOWNLOADING']\n    \n    elif current_state == UPDATE_STATES['DOWNLOADING']:\n        # Assume external system updates download status\n        if verification_status == 'Passed':\n            current_state = UPDATE_STATES['DOWNLOAD_COMPLETE']\n            download_cmd = 'Complete'\n    \n    elif current_state == UPDATE_STATES['DOWNLOAD_COMPLETE']:\n        if user_consent == 'Granted':\n            current_state = UPDATE_STATES['APPLYING']\n            apply_cmd = 'Apply'\n            apply_timer = 0.0\n    \n    elif current_state == UPDATE_STATES['APPLYING']:\n        apply_timer += dt\n        \n        if update_apply_status == 'Success':\n            current_state = UPDATE_STATES['SUCCESS']\n            update_status = 'Success'\n            apply_cmd = 'Complete'\n        elif apply_timer >= apply_timeout:\n            current_state = UPDATE_STATES['FAILED']\n            rollback_cmd = 'Initiate'\n            update_status = 'Failed'\n            apply_cmd = 'Stop'\n    \n    # Update state\n    state.update({\n        'update_state': current_state,\n        'download_command': download_cmd,\n        'apply_command': apply_cmd,\n        'rollback_command': rollback_cmd,\n        'update_status': update_status,\n        'apply_timer': apply_timer\n    })\n    \n    return download_cmd, apply_cmd, rollback_cmd, update_status",
        "score": 3.4285714285714284
      },
      {
        "function": "def window_anti_pinch_control(state, window_motion_command, window_motor_current, \n                              window_velocity, anti_pinch_sensor_status, \n                              pinch_current_threshold, min_velocity_threshold, dt):\n    # Simplified state tracking - more compact style\n    pinch_timer = state.get('pinch_timer', 0)\n    reverse_timer = state.get('reverse_timer', 0)\n    auto_up_disabled = state.get('auto_up_disabled', False)\n    current_command = state.get('current_command', window_motion_command)\n    \n    # Check sensor status first\n    sensor_fault = anti_pinch_sensor_status in ['Fault', 'Unavailable']\n    if sensor_fault:\n        auto_up_disabled = True\n        if current_command == 'AutoUp':\n            current_command = 'Stop'\n    \n    # Handle AutoUp command\n    if current_command == 'AutoUp' and not auto_up_disabled:\n        # Check pinch conditions\n        pinch_detected = False\n        if isinstance(window_motor_current, (int, float)) and window_motor_current > pinch_current_threshold:\n            pinch_detected = True\n        if isinstance(window_velocity, (int, float)) and window_velocity < min_velocity_threshold:\n            pinch_detected = True\n        \n        if pinch_detected:\n            pinch_timer += dt\n            if pinch_timer > 0.05:  # 50ms\n                current_command = 'Reverse'\n                reverse_timer = 0.5  # 500ms\n                pinch_timer = 0\n        else:\n            pinch_timer = 0\n    \n    # Handle reverse timing\n    if current_command == 'Reverse' and reverse_timer > 0:\n        reverse_timer -= dt\n        if reverse_timer <= 0:\n            current_command = 'Stop'\n    \n    # Update external command if different\n    if window_motion_command != current_command:\n        if window_motion_command == 'AutoUp' and auto_up_disabled:\n            current_command = 'Stop'  # Block AutoUp when disabled\n        elif window_motion_command != 'AutoUp':\n            current_command = window_motion_command  # Allow other commands\n    \n    state.update({\n        'pinch_timer': pinch_timer,\n        'reverse_timer': reverse_timer,\n        'auto_up_disabled': auto_up_disabled,\n        'current_command': current_command\n    })\n    \n    return current_command, auto_up_disabled",
        "score": 3.7142857142857135
      },
      {
        "function": "def seat_belt_reminder_system(state, passenger_presence, passenger_belt_latched, vehicle_tempo, dt):\n    \"\"\"\n    Seatbelt reminder with escalating warnings - clean structured approach\n    \"\"\"\n    \n    class ReminderStates:\n        OFF = 'Off'\n        LEVEL1 = 'ChimeLevel1'\n        LEVEL2 = 'ChimeLevel2'\n    \n    # Initialize state variables\n    current_state = state.get('reminder_state', ReminderStates.OFF)\n    level1_timer = state.get('level1_timer', 0.0)\n    warning_active = state.get('warning_active', False)\n    \n    # Reset everything if belt is latched\n    if passenger_belt_latched:\n        current_state = ReminderStates.OFF\n        level1_timer = 0.0\n        warning_active = False\n    else:\n        # Check activation conditions\n        activation_conditions_met = (\n            passenger_presence == 'Detected' and \n            not passenger_belt_latched and \n            vehicle_tempo > 10\n        )\n        \n        if activation_conditions_met:\n            if current_state == ReminderStates.OFF:\n                # Start Level 1 reminder\n                current_state = ReminderStates.LEVEL1\n                level1_timer = 30.0\n                warning_active = False\n                \n            elif current_state == ReminderStates.LEVEL1:\n                # Count down Level 1 timer\n                level1_timer -= dt\n                if level1_timer <= 0:\n                    # Escalate to Level 2\n                    current_state = ReminderStates.LEVEL2\n                    warning_active = True\n            \n            # Level 2 continues until belt is latched\n        else:\n            # Conditions not met - reset to off\n            current_state = ReminderStates.OFF\n            level1_timer = 0.0\n            warning_active = False\n    \n    # Update state\n    state.update({\n        'reminder_state': current_state,\n        'level1_timer': level1_timer,\n        'warning_active': warning_active\n    })\n    \n    return current_state, 'On' if warning_active else 'Off'",
        "score": 3.7142857142857135
      },
      {
        "function": "def audio_volume_controller(state, speed_compensation_enable, vehicle_tempo, alert_tone_active,\n                           base_volume, speed_gain, speed_gain_max, volume_max, alert_duck_level, dt):\n    # Minimal initialization\n    prev_alert = state.get('prev_alert', False)\n    return_timer = state.get('return_timer', 0)\n    ducked_volume = state.get('ducked_volume', None)\n    \n    # Calculate base target volume\n    if speed_compensation_enable and vehicle_tempo != 'Unavailable' and isinstance(vehicle_tempo, (int, float)):\n        # Linear interpolation with clamping\n        speed_factor = min(vehicle_tempo / speed_gain_max, 1.0) if speed_gain_max > 0 else 0\n        target_volume = min(base_volume + (speed_gain * speed_factor), volume_max)\n    else:\n        target_volume = base_volume\n    \n    # Alert ducking logic\n    alert_started = alert_tone_active and not prev_alert\n    alert_ended = not alert_tone_active and prev_alert\n    \n    if alert_started:\n        ducked_volume = min(target_volume, alert_duck_level)\n        return_timer = 0\n    \n    if alert_ended:\n        return_timer = 0.5  # Start 500ms return timer\n    \n    # Handle return from ducking\n    if return_timer > 0:\n        return_timer = max(0, return_timer - dt)\n        if return_timer == 0:\n            ducked_volume = None\n    \n    # Determine final output\n    if alert_tone_active:\n        final_volume = ducked_volume if ducked_volume is not None else min(target_volume, alert_duck_level)\n    elif return_timer > 0 and ducked_volume is not None:\n        final_volume = ducked_volume\n    else:\n        final_volume = target_volume\n    \n    # Update state\n    state['prev_alert'] = alert_tone_active\n    state['return_timer'] = return_timer\n    state['ducked_volume'] = ducked_volume\n    \n    return final_volume, target_volume",
        "score": 2.857142857142857
      },
      {
        "function": "def charging_control_manager(state, charge_port_state, charge_schedule_status, current_time, \n                            next_scheduled_start, grid_current_limit, charging_input_current,\n                            critical_charger_params, power_step, dt):\n    \n    # State tracking with defaults\n    prev_port_state = state.get('prev_port_state', 'Disconnected')\n    charging_state = state.get('charging_state', 'Idle')\n    power_request = state.get('power_request', 100.0)  # Default full power\n    overcurrent_timer = state.get('overcurrent_timer', 0.0)\n    power_reduction_timer = state.get('power_reduction_timer', 0.0)\n    fault_indicator = state.get('fault_indicator', 'Inactive')\n    \n    # Check for critical faults first\n    if any(param == 'Fault' for param in critical_charger_params.values()):\n        charging_state = 'StopCharging'\n        fault_indicator = 'Active'\n        state.update({\n            'charging_state': charging_state,\n            'fault_indicator': fault_indicator,\n            'prev_port_state': charge_port_state\n        })\n        return charging_state, power_request, fault_indicator\n    \n    # Port state transition detection\n    port_latched = (prev_port_state == 'Connected' and charge_port_state == 'Latched')\n    \n    if port_latched and charge_schedule_status == 'Enabled':\n        charging_state = 'AwaitSchedule'\n    \n    # Schedule-based state transitions\n    if charging_state == 'AwaitSchedule' and current_time >= next_scheduled_start:\n        charging_state = 'StartCharging'\n    \n    # Current limiting logic\n    if (grid_current_limit != 'Unavailable' and \n        isinstance(grid_current_limit, (int, float)) and \n        isinstance(charging_input_current, (int, float))):\n        \n        if charging_input_current > grid_current_limit:\n            overcurrent_timer += dt\n            if overcurrent_timer > 2.0:  # Exceeded for more than 2s\n                power_reduction_timer += dt\n                if power_reduction_timer >= 1.0:  # Reduce every 1s\n                    power_request = max(power_request - power_step, 0)\n                    power_reduction_timer = 0.0\n        else:\n            overcurrent_timer = 0.0\n            power_reduction_timer = 0.0\n    \n    # Update persistent state\n    state.update({\n        'prev_port_state': charge_port_state,\n        'charging_state': charging_state,\n        'power_request': power_request,\n        'overcurrent_timer': overcurrent_timer,\n        'power_reduction_timer': power_reduction_timer,\n        'fault_indicator': fault_indicator\n    })\n    \n    return charging_state, power_request, fault_indicator",
        "score": 2.7142857142857144
      },
      {
        "function": "def traction_control_system(state, traction_control_enable, wheel_slip_ratio, \n                           slip_high_threshold, slip_low_threshold, brake_pedal_pressure,\n                           step_size, max_reduction, dt):\n    \"\"\"\n    Traction control with stepped torque reduction - defensive programming style\n    \"\"\"\n    \n    # Initialize state with error checking\n    if 'torque_reduction' not in state:\n        state['torque_reduction'] = 0.0\n    if 'high_slip_timer' not in state:\n        state['high_slip_timer'] = 0.0\n    if 'low_slip_timer' not in state:\n        state['low_slip_timer'] = 0.0\n    if 'reduction_step_timer' not in state:\n        state['reduction_step_timer'] = 0.0\n    if 'increase_step_timer' not in state:\n        state['increase_step_timer'] = 0.0\n    \n    # Safety check - no action if traction control disabled or brake applied\n    if not traction_control_enable or brake_pedal_pressure:\n        return state['torque_reduction']\n    \n    # Input validation\n    if not isinstance(wheel_slip_ratio, (int, float)):\n        return state['torque_reduction']\n    \n    # High slip detection logic\n    if wheel_slip_ratio > slip_high_threshold:\n        state['high_slip_timer'] += dt\n        state['low_slip_timer'] = 0.0  # Reset low slip timer\n        \n        if state['high_slip_timer'] > 0.1:  # 100ms threshold\n            state['reduction_step_timer'] += dt\n            if state['reduction_step_timer'] >= 0.05:  # 50ms steps\n                new_reduction = min(state['torque_reduction'] + step_size, max_reduction)\n                state['torque_reduction'] = new_reduction\n                state['reduction_step_timer'] = 0.0\n    \n    # Low slip recovery logic\n    elif wheel_slip_ratio < slip_low_threshold:\n        state['low_slip_timer'] += dt\n        state['high_slip_timer'] = 0.0  # Reset high slip timer\n        \n        if state['low_slip_timer'] > 0.5:  # 500ms threshold\n            state['increase_step_timer'] += dt\n            if state['increase_step_timer'] >= 0.1:  # 100ms steps\n                new_reduction = max(state['torque_reduction'] - step_size, 0.0)\n                state['torque_reduction'] = new_reduction\n                state['increase_step_timer'] = 0.0\n    \n    # Between thresholds - reset timers but maintain current reduction\n    else:\n        state['high_slip_timer'] = 0.0\n        state['low_slip_timer'] = 0.0\n    \n    return state['torque_reduction']",
        "score": 3.4285714285714284
      },
      {
        "function": "def driver_profile_manager(state, driver_auth_token, user_override_detected, seat_movement_in_progress,\n                          driver_door_status, profile_load_ack, recognized_tokens, dt):\n    # Functional style with early returns\n    def is_token_recognized(token):\n        return token in recognized_tokens and token != 'Unknown'\n    \n    def reset_timers():\n        return {'recognition_timer': 0.0, 'load_timeout_timer': 0.0, 'notification_queued': False}\n    \n    # Get state with defaults\n    prev_token = state.get('prev_auth_token', 'Unknown')\n    load_command = state.get('load_command', 'None')\n    timers = state.get('timers', reset_timers())\n    prev_door_status = state.get('prev_door_status', 'Closed')\n    \n    # Token transition detection\n    token_recognized = (prev_token != driver_auth_token and \n                       is_token_recognized(driver_auth_token))\n    \n    door_opened = (prev_door_status == 'Closed' and driver_door_status == 'Open')\n    door_closed = (prev_door_status == 'Open' and driver_door_status == 'Closed')\n    \n    # Main state machine logic\n    if token_recognized:\n        timers = reset_timers()\n        load_command = 'Standby'\n    \n    if load_command == 'Standby':\n        if user_override_detected:\n            load_command = 'None'\n        else:\n            timers['recognition_timer'] += dt\n            if timers['recognition_timer'] >= 10.0:\n                load_command = 'LoadMatchedProfile'\n                timers['load_timeout_timer'] = 0.0\n    \n    if load_command == 'LoadMatchedProfile':\n        # Handle door opening during loading\n        if door_opened and seat_movement_in_progress:\n            load_command = 'Pause'\n        else:\n            # Check for timeout\n            timers['load_timeout_timer'] += dt\n            if profile_load_ack == 'Loaded':\n                load_command = 'Complete'\n            elif timers['load_timeout_timer'] >= 15.0:\n                load_command = 'Abort'\n                timers['notification_queued'] = True\n    \n    if load_command == 'Pause':\n        if door_closed:\n            load_command = 'LoadMatchedProfile'\n            # Resume timeout from where it left off\n    \n    # Update state\n    state.update({\n        'prev_auth_token': driver_auth_token,\n        'load_command': load_command,\n        'timers': timers,\n        'prev_door_status': driver_door_status\n    })\n    \n    return load_command, timers['notification_queued']",
        "score": 2.857142857142857
      },
      {
        "function": "def sunroof_rain_protection(state, rain_sensor_state, vehicle_lock_state, sunroof_position, \n                           obstruction_detected, dt):\n    \"\"\"Rain-triggered sunroof control - verbose style with extensive comments\"\"\"\n    \n    # State variable initialization with comprehensive defaults\n    previous_rain_state = state.get('previous_rain_state', 'Dry')\n    sunroof_command = state.get('sunroof_command', 'Stop')\n    dry_duration_timer = state.get('dry_duration_timer', 0.0)\n    auto_close_enabled = state.get('auto_close_enabled', True)\n    is_closing_due_to_rain = state.get('is_closing_due_to_rain', False)\n    previous_obstruction = state.get('previous_obstruction', False)\n    notification_pending = state.get('notification_pending', False)\n    \n    # Edge detection for rain sensor transitions\n    rain_wet_transition = (previous_rain_state != 'Wet' and rain_sensor_state == 'Wet')\n    rain_dry_transition = (previous_rain_state != 'Dry' and rain_sensor_state == 'Dry')\n    \n    # Edge detection for obstruction sensor\n    obstruction_detected_edge = (not previous_obstruction and obstruction_detected)\n    \n    # Reset notification flag at start of each cycle\n    notification_pending = False\n    \n    # Main rain protection logic\n    if rain_wet_transition and auto_close_enabled:\n        # Check all conditions for automatic closing\n        conditions_met_for_auto_close = (\n            vehicle_lock_state == 'Locked' and\n            isinstance(sunroof_position, (int, float)) and\n            sunroof_position > 0\n        )\n        \n        if conditions_met_for_auto_close:\n            sunroof_command = 'Close'\n            is_closing_due_to_rain = True\n            # Reset dry timer since we're wet again\n            dry_duration_timer = 0.0\n    \n    # Handle obstruction during rain-triggered closing\n    if is_closing_due_to_rain and obstruction_detected_edge:\n        sunroof_command = 'Stop'\n        is_closing_due_to_rain = False\n        notification_pending = True\n        \n        # Set position to maximum of current position or 10%\n        # This assumes the caller will handle the position update\n        # based on the returned command and notification\n    \n    # Handle dry conditions and re-enabling of automatic closing\n    if rain_sensor_state == 'Dry':\n        dry_duration_timer += dt\n        \n        # Re-enable automatic closing after 10 minutes of dry conditions\n        if dry_duration_timer >= 600.0:  # 10 minutes = 600 seconds\n            auto_close_enabled = True\n            # Keep the timer running to track total dry time\n    else:\n        # Reset dry timer if not dry\n        dry_duration_timer = 0.0\n    \n    # Handle completion of rain-triggered closing\n    if is_closing_due_to_rain and sunroof_command == 'Close':\n        # In a real system, we'd check if closing is complete\n        # For this implementation, we assume external position feedback\n        if isinstance(sunroof_position, (int, float)) and sunroof_position <= 0:\n            is_closing_due_to_rain = False\n            sunroof_command = 'Stop'\n    \n    # Update state dictionary with all tracked values\n    state.update({\n        'previous_rain_state': rain_sensor_state,\n        'sunroof_command': sunroof_command,\n        'dry_duration_timer': dry_duration_timer,\n        'auto_close_enabled': auto_close_enabled,\n        'is_closing_due_to_rain': is_closing_due_to_rain,\n        'previous_obstruction': obstruction_detected,\n        'notification_pending': notification_pending\n    })\n    \n    # Calculate suggested position for obstruction case\n    suggested_position = None\n    if notification_pending and isinstance(sunroof_position, (int, float)):\n        suggested_position = max(sunroof_position, 10.0)\n    \n    return sunroof_command, notification_pending, suggested_position",
        "score": 4.142857142857143
      },
      {
        "function": "def coolant_pump_control(state, temp_left, temp_right, delta_threshold, hysteresis_delta, dt):\n    # Compact implementation with inline state management\n    s = state  # Short alias for brevity\n    s.setdefault('pump_on', False)\n    s.setdefault('stable_timer', 0.0)\n    s.setdefault('fault_timer', 0.0)\n    \n    fault_detected = temp_left in ['Fault', 'Unavailable'] or temp_right in ['Fault', 'Unavailable']\n    \n    if fault_detected and s['pump_on']:\n        s['fault_timer'] += dt\n        if s['fault_timer'] >= 1.0:\n            s['pump_on'] = False\n            s['fault_timer'] = 0.0\n            return 'Off', 'Active'  # pump command, fault indicator\n    elif not fault_detected:\n        s['fault_timer'] = 0.0\n        \n        if isinstance(temp_left, (int, float)) and isinstance(temp_right, (int, float)):\n            temp_diff = abs(temp_left - temp_right)\n            \n            if not s['pump_on'] and temp_diff > delta_threshold:\n                s['pump_on'] = True\n                s['stable_timer'] = 0.0\n            elif s['pump_on'] and temp_diff < hysteresis_delta:\n                s['stable_timer'] += dt\n                if s['stable_timer'] >= 30.0:\n                    s['pump_on'] = False\n                    s['stable_timer'] = 0.0\n            elif s['pump_on'] and temp_diff >= hysteresis_delta:\n                s['stable_timer'] = 0.0\n    \n    return 'On' if s['pump_on'] else 'Off', 'Inactive'",
        "score": 3.2857142857142856
      }
    ],
    "signature": {
      "instructions": "Evaluate the quality of the provided function. Evaluate the code quality based on \nmetrics like readability, maintainability, efficiency, and adherence to best practices.\n\nScore based on these specifications:\n- 1 = Poor quality: The code is difficult to read, understand, and maintain. It may contain\n  inefficient algorithms, lack of comments, and poor structure.\n- 2 = Below average quality: The code has some readability and maintainability issues. \n  It may be inefficient in parts and lacks proper documentation.\n- 3 = Fair quality: The code is somewhat readable and maintainable but has several\n  areas for improvement. It may have some inefficient parts and lacks consistency in style.\n- 4 = Good quality: The code is generally readable and maintainable. It follows\n  best practices and has a good structure, but there may be minor inefficiencies or\n  areas for improvement.\n- 5 = Excellent quality: The code is highly readable, maintainable, and efficient.\n  It adheres to best practices, has a clear structure, and is well-documented.\n\nThe return value of this function should always be an continuous number between 1 and 5.",
      "fields": [
        {
          "prefix": "Function:",
          "description": "Function to be evaluated."
        },
        {
          "prefix": "Score:",
          "description": "A float representing the code quality score of the function."
        }
      ]
    },
    "lm": null
  },
  "metadata": {
    "dependency_versions": {
      "python": "3.12",
      "dspy": "3.0.3",
      "cloudpickle": "3.1"
    }
  }
}
